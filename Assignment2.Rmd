# Package Downloads

```{r message=FALSE, eval = FALSE}
if (!require("BiocManager", quietly = TRUE))
  install.packages("BiocManager", repos = "https://cloud.r-project.org")
BiocManager::install(version = "3.21")
if (!requireNamespace("DESeq2", quietly = TRUE)) {
  BiocManager::install("DESeq2")
}
install.packages("devtools", repos = "https://cloud.r-project.org")
install.packages("GenomeInfoDb", repos = "https://cloud.r-project.org")
install.packages("tidyverse", repos = "https://cloud.r-project.org")
# Install the Homo Sapiens package
if (!("org.Hs.eg.db" %in% installed.packages())) {
  BiocManager::install("org.Hs.eg.db", update = FALSE)
}
```

# Section 1

## Section 1a

```{r}
# Attach the library
library(org.Hs.eg.db)

# We will need this so we can use the pipe: %>%
library(magrittr)

# Create the data folder if it doesn't exist
if (!dir.exists("data")) {
  dir.create("data")
}

# Define the file path to the plots directory
plots_dir <- "plots"

# Create the plots folder if it doesn't exist
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir)
}

# Define the file path to the results directory
results_dir <- "results"

# Create the results folder if it doesn't exist
if (!dir.exists(results_dir)) {
  dir.create(results_dir)
}

# Define the file path to the data directory
data_dir <- file.path("data", "SRP192714")

# Declare the file path to the gene expression matrix file
data_file <- file.path(data_dir, "SRP192714.tsv")

# Read in data TSV file
expression_df <- readr::read_tsv(data_file) %>%
  tibble::column_to_rownames("Gene")

# Load refine.bio metadata
refinebio_meta <- readr::read_tsv(file.path(data_dir, "metadata_SRP192714.tsv"))
rownames(refinebio_meta) <- refinebio_meta$refinebio_accession_code

# Load GEO metadata (CSV)
geo_meta <- readr::read_csv("data/GSE129882_PhenoData.transcript.csv")

# Merge on 'refinebio_title' (refine.bio) and 'Sample' (GEO), keep 'refinebio_title' as column name
if ("Sample" %in% colnames(geo_meta) && "refinebio_title" %in% colnames(refinebio_meta)) {
  merged_meta <- dplyr::left_join(refinebio_meta, geo_meta, by = c("refinebio_title" = "Sample"))
} else {
  merged_meta <- refinebio_meta
}

# Choose how many samples to keep for this run (set to Inf to keep all samples)
sample_limit <- Inf

all_samples <- colnames(expression_df)
selected_samples <- all_samples
if (is.finite(sample_limit)) {
  selected_samples <- all_samples[seq_len(min(sample_limit, length(all_samples)))]
}

is_trimmed_run <- length(selected_samples) < length(all_samples)
run_label <- if (is_trimmed_run) paste0("trimmed_", length(selected_samples)) else "full"

expression_df <- expression_df[, selected_samples, drop = FALSE]

merged_meta <- merged_meta %>%
  dplyr::filter(refinebio_accession_code %in% selected_samples)
rownames(merged_meta) <- merged_meta$refinebio_accession_code

merged_meta_path <- file.path(data_dir, "metadata_SRP192714_merged.tsv")
readr::write_tsv(merged_meta, merged_meta_path)

```

## Section 1b

```{r}
# Bring back the "Gene" column in preparation for mapping
expression_df <- expression_df %>%
  tibble::rownames_to_column("Gene")

# Map Ensembl IDs to their first mapped Symbol
gene_symbols <- mapIds(
  org.Hs.eg.db,
  keys = expression_df$Gene,
  keytype = "ENSEMBL",
  column = "SYMBOL",
  multiVals = "first"
)

# Add the mapped symbols as a new column
expression_df$Symbol <- gene_symbols[expression_df$Gene]

# Reorder columns to have Gene, Symbol, then the rest
expression_df <- expression_df %>%
  dplyr::select(Gene, Symbol, dplyr::everything(), -Gene)

# Write mapped data frame to output file
readr::write_tsv(expression_df, file.path(
  results_dir,
  "SRP192714_Symbols.tsv"
))
```

## Section 1c

```{r}

# Get matrix size
matrix_dim <- dim(expression_df)
cat("Expression matrix dimensions (genes x samples):", matrix_dim[1], "x", matrix_dim[2], "\n")

# Number of genes
cat("Number of genes:", nrow(expression_df), "\n")

# Select only numeric columns for log transformation
expr_numeric <- expression_df %>% dplyr::select(where(is.numeric))

# Log-scale the data (add pseudocount to avoid log(0))
log_expr <- log2(expr_numeric + 1)

# Calculate per-gene median expression
gene_medians <- apply(log_expr, 1, median, na.rm = TRUE)

# Show summary statistics for gene medians
summary(gene_medians)

# Density plot of per-gene median expression
library(ggplot2)
plot_obj <- ggplot(data.frame(median=gene_medians), aes(x=median)) +
  geom_density(fill="skyblue", alpha=0.5) +
  labs(title="Density of Per-Gene Median Expression (log2 scale)",
       x="Median log2(expression + 1)",
       y="Density")

# Save plot to the plots directory
plot_path <- file.path(plots_dir, "per_gene_median_density.png")
ggsave(plot_path, plot=plot_obj, width=6, height=4, dpi=300)

# Also print the plot in the notebook
plot_obj
```

The dataset contains `r format(matrix_dim[1], big.mark = ",")` genes measured across `r matrix_dim[2]` samples. The summary statistics show that most genes have low median expression (median ≈ `r round(median(gene_medians), 2)` on the log2 scale), with a long tail of higher expression values (max ≈ `r round(max(gene_medians), 2)`). From our research, this is typical for transcriptome data, where a small number of genes are highly expressed while the majority have low expression. The density plot visualizes this distribution, showing a peak at lower expression values and a gradual decline towards higher values. Log transformation helps to reduce the impact of extreme values and makes the distribution more interpretable. \# Section 2 \## Section 2a-c

```{r}
library(DESeq2)

expr_mat <- expression_df %>% dplyr::select(where(is.numeric))
meta <- merged_meta

common_samples <- intersect(colnames(expr_mat), meta$refinebio_accession_code)
expr_mat <- expr_mat %>% dplyr::select(all_of(common_samples))
meta <- meta %>%
  dplyr::filter(refinebio_accession_code %in% common_samples)
rownames(meta) <- meta$refinebio_accession_code

cts <- as.matrix(expr_mat)
cts <- cts[, rownames(meta), drop = FALSE]
cts[cts < 0] <- 0
cts <- round(cts)

stopifnot(ncol(cts) == nrow(meta))

plot_title <- sprintf("PCA of %d Samples (colored by Exposure)", length(common_samples))
plot_file <- paste0(run_label, "_pca_exposure.png")

dds <- DESeqDataSetFromMatrix(countData = cts,
                              colData = meta,
                              design = ~ refinebio_title)
dds <- DESeq(dds)
vsd <- vst(dds, blind = FALSE)
pca_data <- plotPCA(vsd, intgroup = c("Exposure"), returnData = TRUE)
pca_data$Sample <- rownames(pca_data)
pca_data <- dplyr::left_join(
  pca_data,
  meta %>% dplyr::select(refinebio_accession_code, Exposure),
  by = c("Sample" = "refinebio_accession_code")
)
if (!"Exposure" %in% colnames(pca_data) || all(is.na(pca_data$Exposure))) {
  pca_data$Exposure <- meta$Exposure[match(pca_data$Sample, meta$refinebio_accession_code)]
}
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2, color = Exposure)) +
  geom_point(size = 3, alpha = 0.8) +
  labs(title = plot_title, x = "PC1", y = "PC2") +
  theme_minimal()
ggsave(filename = file.path(plots_dir, plot_file), plot = pca_plot, width = 6, height = 4, dpi = 300)
pca_plot
```

## Section 2d packages

```{r}
if (is.null(getOption("repos")) || identical(getOption("repos")[["CRAN"]], "@CRAN@")) {
  options(repos = c(CRAN = "https://cloud.r-project.org"))
}
if (!requireNamespace("M3C", quietly = TRUE)) install.packages("M3C", repos = getOption("repos")[["CRAN"]])
if (!requireNamespace("Rtsne", quietly = TRUE)) install.packages("Rtsne", repos = getOption("repos")[["CRAN"]])
if (!requireNamespace("umap", quietly = TRUE)) install.packages("umap", repos = getOption("repos")[["CRAN"]])
if (!requireNamespace("matrixStats", quietly = TRUE)) install.packages("matrixStats", repos = getOption("repos")[["CRAN"]])
```

## Section 2d i

```{r}
## --- 2d i: t-SNE using Rtsne (colored by Exposure) ---
# deps
library(SummarizedExperiment)   # for assay()
library(matrixStats)            # for row/col variance
library(Rtsne)
library(ggplot2)

set.seed(42)

# 1) pull variance-stabilized matrix and align meta
vsd_gxs <- SummarizedExperiment::assay(vsd)        # genes x samples
if (!identical(rownames(meta), colnames(vsd_gxs))) {
  stopifnot("refinebio_accession_code" %in% colnames(meta))
  rownames(meta) <- meta$refinebio_accession_code
  meta <- meta[colnames(vsd_gxs), , drop = FALSE]
}
# keep only labeled samples
keep <- !is.na(meta$Exposure)
vsd_gxs <- vsd_gxs[, keep, drop = FALSE]
meta     <- meta[keep, , drop = FALSE]
meta$Exposure <- factor(meta$Exposure)

# 2) select top variable genes and reduce to ~50 PCs (denoising)
ngenes <- min(2000, nrow(vsd_gxs))                           # 2k or fewer if dataset smaller
top_genes <- head(order(matrixStats::rowVars(vsd_gxs), decreasing = TRUE), ngenes)
X <- t(vsd_gxs[top_genes, , drop = FALSE])                   # samples x genes

pcs   <- prcomp(X, center = TRUE, scale. = TRUE)
pcmat <- pcs$x[, 1:min(50, ncol(pcs$x)), drop = FALSE]       # samples x PCs

# 3) run t-SNE (safe perplexity ~ n/3 clamped to 5..30)
n  <- nrow(pcmat)
px <- max(5, min(30, floor((n - 1) / 3)))
tsne_out <- Rtsne(
  pcmat,
  perplexity = px,
  max_iter = 1000,
  check_duplicates = FALSE,
  verbose = FALSE
)

# 4) plot
tsne_df <- data.frame(
  tSNE1 = tsne_out$Y[, 1],
  tSNE2 = tsne_out$Y[, 2],
  Exposure = meta$Exposure
)

p_tsne <- ggplot(tsne_df, aes(tSNE1, tSNE2, color = Exposure)) +
  geom_point(size = 2.6, alpha = 0.9) +
  labs(
    title = paste0("t-SNE of Samples (Rtsne; perplexity=", px, "; 50 PCs, top ", ngenes, " genes)"),
    x = "t-SNE 1", y = "t-SNE 2"
  ) +
  theme_minimal()

if (!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
outfile_tsne <- paste0(run_label, "_tsne_Rtsne.png")
ggsave(file.path(plots_dir, outfile_tsne), p_tsne, width = 7, height = 5, dpi = 300)
p_tsne
```

## Section 2d ii

```{r}
## --- 2d ii: UMAP using 'umap' (colored by Exposure) ---
library(SummarizedExperiment)
library(matrixStats)
library(umap)
library(ggplot2)

set.seed(42)

vsd_gxs <- SummarizedExperiment::assay(vsd)
if (!identical(rownames(meta), colnames(vsd_gxs))) {
  stopifnot("refinebio_accession_code" %in% colnames(meta))
  rownames(meta) <- meta$refinebio_accession_code
  meta <- meta[colnames(vsd_gxs), , drop = FALSE]
}
keep <- !is.na(meta$Exposure)
vsd_gxs <- vsd_gxs[, keep, drop = FALSE]
meta     <- meta[keep, , drop = FALSE]
meta$Exposure <- factor(meta$Exposure)

ngenes <- min(2000, nrow(vsd_gxs))
top_genes <- head(order(matrixStats::rowVars(vsd_gxs), decreasing = TRUE), ngenes)
X <- t(vsd_gxs[top_genes, , drop = FALSE])

pcs   <- prcomp(X, center = TRUE, scale. = TRUE)
pcmat <- pcs$x[, 1:min(50, ncol(pcs$x)), drop = FALSE]

n <- nrow(pcmat)
nn <- max(10, min(50, round(n / 3)))

cfg <- umap::umap.defaults
cfg$n_neighbors <- nn
cfg$min_dist    <- 0.3
cfg$metric      <- "euclidean"

um <- umap::umap(pcmat, config = cfg)

umap_df <- data.frame(
  UMAP1 = um$layout[, 1],
  UMAP2 = um$layout[, 2],
  Exposure = meta$Exposure
)

p_umap <- ggplot(umap_df, aes(UMAP1, UMAP2, color = Exposure)) +
  geom_point(size = 2.6, alpha = 0.9) +
  labs(
    title = paste0("UMAP of Samples (umap; n_neighbors=", nn, ", min_dist=0.3; 50 PCs, top ", ngenes, " genes)"),
    x = "UMAP 1", y = "UMAP 2"
  ) +
  theme_minimal()

if (!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
outfile_umap <- paste0(run_label, "_umap.png")
ggsave(file.path(plots_dir, outfile_umap), p_umap, width = 7, height = 5, dpi = 300)
p_umap
```

# Section 2e

Similarities • All three methods (PCA, t-SNE, UMAP) reduce the high-dimensional gene expression data into 2D, letting us see patterns between samples. • In each, samples tend to group by Exposure status (or whichever grouping variable you’re using). • Outliers and variability across samples are visible in all three.

Differences • PCA: Captures global variance structure, shows the main linear directions of variability. Often looks more “spread out” but may miss subtle clusters. • t-SNE: Focuses on local structure, separates clusters more strongly. However, distances between clusters aren’t always meaningful (clusters may look far but be closer in high-D space). • UMAP: Balances global and local structure, sometimes keeps a more interpretable overall shape while still revealing clusters.

# Section 2f

Findings • Across all three dimensionality reduction methods, samples show grouping consistent with Exposure categories, suggesting exposure status drives significant variation in gene expression. • PCA highlights the major global variance, but t-SNE and UMAP give a clearer view of sub-clusters. • UMAP provides a balance, maintaining both separation of clusters and an interpretable global structure. • Together, these plots confirm that exposure effects are strong and detectable across different approaches.

# Section 3a-b

```{r}
if (is.null(getOption("repos")) || identical(getOption("repos")[["CRAN"]], "@CRAN@")) {
  options(repos = c(CRAN = "https://cloud.r-project.org"))
}
if (!requireNamespace("ggrepel", quietly = TRUE)) {
  install.packages("ggrepel", repos = getOption("repos")["CRAN"])
}
```

```{r attach library, echo = FALSE}
# Attach the DESeq2 library
library(DESeq2)

# Attach the ggplot2 library for plotting
library(ggplot2)

# We will need this so we can use the pipe: %>%
library(magrittr)

set.seed(12345)
```

```{r Read-in Metadata}
metadata_file <- file.path(data_dir, "metadata_SRP192714_merged.tsv")
metadata <- readr::read_tsv(metadata_file)
```

```{r }
# ---- 3a-b: Differential expression: DENV vs Naive ----
suppressPackageStartupMessages({
  library(readr); library(dplyr); library(stringr); library(tibble)
  library(DESeq2); library(ggplot2)
})

# paths (match earlier sections)
expr_path <- "data/SRP192714/SRP192714.tsv"
meta_path <- "data/SRP192714/metadata_SRP192714_merged.tsv"

# 1) read counts and merged metadata
counts <- readr::read_tsv(expr_path, show_col_types = FALSE) |>
  tibble::column_to_rownames("Gene") |>
  as.matrix()
mode(counts) <- "numeric"

metadata <- readr::read_tsv(meta_path, show_col_types = FALSE)

if (exists("selected_samples")) {
  keep_ids <- intersect(colnames(counts), selected_samples)
  counts <- counts[, keep_ids, drop = FALSE]
  metadata <- metadata %>% dplyr::filter(refinebio_accession_code %in% keep_ids)
}

# 2) make a clean two-level grouping: Exposure2 = Naive vs DENV
stopifnot(all(c("refinebio_accession_code","Exposure") %in% names(metadata)))
metadata <- metadata |>
  mutate(
    Exposure2 = case_when(
      str_to_lower(Exposure) %in% c("naive","mock","control","uninfected","healthy") ~ "Naive",
      str_detect(str_to_lower(Exposure), "denv|dengue") ~ "DENV",
      TRUE ~ NA_character_
    )
  )

# 3) align samples (use only samples with Exposure2)
metadata <- metadata |> filter(!is.na(Exposure2))
common_ids <- intersect(colnames(counts), metadata$refinebio_accession_code)
if (length(common_ids) == 0) stop("No overlapping sample IDs between counts and metadata.")

# subset BOTH objects to the same ids and order identically
common_ids <- sort(common_ids)  # deterministic order
counts  <- counts[, common_ids, drop = FALSE]
metadata <- metadata |>
  filter(refinebio_accession_code %in% common_ids) |>
  arrange(match(refinebio_accession_code, common_ids))

stopifnot(identical(colnames(counts), metadata$refinebio_accession_code))

# finalize colData
metadata$Exposure2 <- factor(metadata$Exposure2, levels = c("Naive","DENV"))
rownames(metadata) <- metadata$refinebio_accession_code

# 4) basic QC on counts
counts[counts < 0] <- 0
counts <- round(counts)
keep_genes <- rowSums(counts) >= 10
counts_f <- counts[keep_genes, , drop = FALSE]

cat("DE input — genes x samples:", nrow(counts_f), "x", ncol(counts_f), "\n")
print(table(metadata$Exposure2))

# 5) DESeq2
dds <- DESeqDataSetFromMatrix(countData = counts_f,
                              colData   = metadata,
                              design    = ~ Exposure2)
dds <- DESeq(dds)

# 6) results: DENV vs Naive (Naive is reference because of factor levels above)
res <- results(dds, contrast = c("Exposure2","DENV","Naive"))

# tidy + save
results_dir <- "results"; plots_dir <- "plots"
if (!dir.exists(results_dir)) dir.create(results_dir, recursive = TRUE)
if (!dir.exists(plots_dir))   dir.create(plots_dir,   recursive = TRUE)

res_df <- as.data.frame(res) |>
  tibble::rownames_to_column("GeneID") |>
  mutate(padj = ifelse(is.na(padj), 1, padj),
         sig  = padj < 0.05) |>
  arrange(padj)

readr::write_tsv(res_df,           file.path(results_dir, "DE_full_results_DENV_vs_Naive.tsv"))
readr::write_tsv(head(res_df, 50), file.path(results_dir, "DE_top50_DENV_vs_Naive.tsv"))
cat("Significant genes (padj < 0.05):", sum(res_df$sig), "\n")

# Build volcano data from res_df created earlier
volc_df <- res_df %>%
  dplyr::filter(!is.na(padj) & padj > 0) %>%
  dplyr::mutate(nlog10p = -log10(padj))

p_volc <- ggplot(volc_df, aes(x = log2FoldChange, y = nlog10p, color = sig)) +
  geom_point(alpha = 0.75, size = 1.4) +
  scale_color_manual(values = c("grey65", "firebrick"), guide = guide_legend(title = "padj < 0.05")) +
  labs(
    title = "Volcano: DENV vs Naive",
    x = "log2 Fold Change (DENV vs Naive)",
    y = "-log10 adjusted p-value"
  ) +
  theme_minimal()

# save and print
ggsave(file.path(plots_dir, "DE_volcano_DENV_vs_Naive.png"),
       p_volc, width = 7, height = 5, dpi = 300)
p_volc
```

# Section 3c

```{r}
suppressPackageStartupMessages({ library(dplyr); library(ggplot2) })

stopifnot(exists("res_df"), exists("results_dir"), exists("plots_dir"))

# basic significance and direction
sum_sig   <- sum(res_df$padj < 0.05, na.rm = TRUE)
sum_up    <- sum(res_df$padj < 0.05 & res_df$log2FoldChange >  0, na.rm = TRUE)  # higher in DENV
sum_down  <- sum(res_df$padj < 0.05 & res_df$log2FoldChange <  0, na.rm = TRUE)  # lower in DENV

cat("3c) Significant genes (padj < 0.05):", sum_sig, "\n")
cat("    Up in DENV:", sum_up, " | Down in DENV:", sum_down, "\n")

# tidy summary table and save
de_summary <- data.frame(
  comparison = "DENV vs Naive",
  n_sig = sum_sig,
  n_up  = sum_up,
  n_down = sum_down,
  stringsAsFactors = FALSE
)
if (!dir.exists(results_dir)) dir.create(results_dir, recursive = TRUE)
readr::write_tsv(de_summary, file.path(results_dir, "DE_summary_DENV_vs_Naive.tsv"))

# small bar plot of up/down counts
plot_df <- data.frame(
  direction = c("Up in DENV","Down in DENV"),
  n = c(sum_up, sum_down)
)
if (!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
p_counts <- ggplot(plot_df, aes(direction, n, fill = direction)) +
  geom_col() +
  labs(title = "Significant DE genes (padj < 0.05)", x = NULL, y = "Count") +
  theme_minimal() + theme(legend.position = "none")
ggsave(file.path(plots_dir, "DE_sig_counts_bar.png"), p_counts, width = 6, height = 4, dpi = 300)
p_counts
```

# Section 3d

```{r}
suppressPackageStartupMessages({ library(org.Hs.eg.db); library(dplyr); library(ggplot2); library(ggrepel) })


clean_ids <- sub("\\.\\d+$", "", res_df$GeneID)

symb <- AnnotationDbi::mapIds(
  org.Hs.eg.db,
  keys = clean_ids,
  keytype = "ENSEMBL",
  column = "SYMBOL",
  multiVals = "first"
)

res_annot <- res_df %>%
  mutate(ENSEMBL = clean_ids,
         Symbol  = unname(symb[clean_ids])) %>%
  relocate(ENSEMBL, Symbol, .before = GeneID)

# Save full annotated and top lists
readr::write_tsv(res_annot, file.path(results_dir, "DE_full_results_DENV_vs_Naive_annotated.tsv"))
readr::write_tsv(head(res_annot %>% arrange(padj), 50), file.path(results_dir, "DE_top50_annotated.tsv"))

# Labeled volcano highlighting top 10 by padj
volc_df <- res_annot %>%
  filter(!is.na(padj) & padj > 0) %>%
  mutate(nlog10p = -log10(padj))

lab_genes <- volc_df %>%
  arrange(padj) %>%
  dplyr::slice(1:min(10, n())) %>%
  pull(Symbol)

p_volc_lab <- ggplot(volc_df, aes(x = log2FoldChange, y = nlog10p, color = padj < 0.05)) +
  geom_point(alpha = 0.75, size = 1.3) +
  scale_color_manual(values = c("grey70","firebrick"), labels = c("NS","padj<0.05"), name = "") +
  geom_text_repel(
    data = subset(volc_df, Symbol %in% lab_genes),
    aes(label = Symbol), size = 3, max.overlaps = 50
  ) +
  labs(title = "Volcano (DENV vs Naive) — top 10 labeled",
       x = "log2 Fold Change (DENV vs Naive)", y = "-log10 adjusted p-value") +
  theme_minimal()

ggsave(file.path(plots_dir, "DE_volcano_DENV_vs_Naive_labeled.png"),
       p_volc_lab, width = 7.5, height = 5.2, dpi = 300)
p_volc_lab
```

# Section 3e

```{r}
norm_counts <- DESeq2::counts(dds, normalized = TRUE)

# pick top 30 DE genes (by padj), ensure they exist in norm matrix
top30 <- res_annot %>%
  filter(!is.na(padj)) %>%
  arrange(padj) %>%
  dplyr::slice(1:min(30, n())) %>%
  pull(GeneID)
top30 <- intersect(top30, rownames(norm_counts))

# write wide matrix (genes x samples) for these genes
if (length(top30) >= 2) {
  top_norm <- norm_counts[top30, , drop = FALSE] %>%
    as.data.frame() %>%
    rownames_to_column("GeneID")
  readr::write_tsv(top_norm, file.path(results_dir, "NormalizedCounts_top30.tsv"))
}

# Plot counts for top 3 genes (if present), save PNGs
plot_ids <- head(top30, 3)
if (length(plot_ids) > 0) {
  if (!dir.exists(plots_dir)) dir.create(plots_dir, recursive = TRUE)
  for (gid in plot_ids) {
    png(file.path(plots_dir, paste0("plotCounts_", gid, ".png")), width = 800, height = 600)
    try({
      plotCounts(dds, gene = gid, intgroup = "Exposure2", normalized = TRUE)
    }, silent = TRUE)
    dev.off()
  }
}
```

# Section 4a

```{r}
# Step 4: Extract significantly differentially expressed genes and generate heatmap

# Load required libraries
if (!requireNamespace("ComplexHeatmap", quietly = TRUE)) {
  BiocManager::install("ComplexHeatmap")
}
if (!requireNamespace("circlize", quietly = TRUE)) {
  BiocManager::install("circlize")
}
if (!requireNamespace("grid", quietly = TRUE)) {
  install.packages("grid")
}

suppressPackageStartupMessages({
  library(ComplexHeatmap)
  library(circlize)
  library(DESeq2)
  library(dplyr)
  library(RColorBrewer)
  library(grid)
})

# Ensure we have the DESeq2 results and normalized counts from previous steps
if (!exists("dds") || !exists("res_df")) {
  stop("Please run the differential expression analysis (Step 3) first to generate 'dds' and 'res_df' objects")
}

# Extract significantly differentially expressed genes
# Using adjusted p-value < 0.05 and absolute log2 fold change > 1
sig_genes <- res_df %>%
  filter(padj < 0.05 & abs(log2FoldChange) > 1) %>%
  pull(GeneID)

cat("Number of significantly differentially expressed genes:", length(sig_genes), "\n")

# If no significant genes with fold change > 1, use less stringent criteria
if (length(sig_genes) == 0) {
  cat("No genes with |log2FC| > 1, using padj < 0.05 only\n")
  sig_genes <- res_df %>%
    filter(padj < 0.05) %>%
    pull(GeneID)
}

# If still no significant genes, use top 50 by p-value
if (length(sig_genes) == 0) {
  cat("No significant genes found, using top 50 genes by p-value\n")
  sig_genes <- res_df %>%
    arrange(pvalue) %>%
    slice_head(n = 50) %>%
    pull(GeneID)
}

# Get normalized counts for significant genes
norm_counts <- DESeq2::counts(dds, normalized = TRUE)

# Filter for significant genes that exist in our count matrix
sig_genes_present <- intersect(sig_genes, rownames(norm_counts))
cat("Number of significant genes present in count matrix:", length(sig_genes_present), "\n")

# If we have too many genes, select top by adjusted p-value
max_genes <- 100
if (length(sig_genes_present) > max_genes) {
  top_sig_genes <- res_df %>%
    filter(GeneID %in% sig_genes_present) %>%
    arrange(padj) %>%
    slice_head(n = max_genes) %>%
    pull(GeneID)
  sig_genes_present <- top_sig_genes
  cat("Using top", max_genes, "genes by adjusted p-value for heatmap\n")
}

# Extract normalized counts for significant genes
heatmap_data <- norm_counts[sig_genes_present, , drop = FALSE]

# Log2 transform (add pseudocount to avoid log(0))
log_heatmap_data <- log2(heatmap_data + 1)

# Z-score normalization (scale by rows/genes)
scaled_data <- t(scale(t(log_heatmap_data)))

# Handle any NaN or infinite values
scaled_data[!is.finite(scaled_data)] <- 0

# Create sample grouping information
sample_groups <- rep("Unknown", ncol(scaled_data))
names(sample_groups) <- colnames(scaled_data)

# Try to get grouping information from metadata
if (exists("meta") && "Exposure2" %in% colnames(meta)) {
  common_samples <- intersect(colnames(scaled_data), rownames(meta))
  sample_groups[common_samples] <- as.character(meta[common_samples, "Exposure2"])
} else if (exists("metadata") && any(c("Exposure", "Exposure2") %in% colnames(metadata))) {
  # Create basic grouping from original metadata
  temp_meta <- metadata %>%
    mutate(
      Exposure2 = case_when(
        str_to_lower(Exposure) %in% c("naive","mock","control","uninfected","healthy") ~ "Naive",
        str_detect(str_to_lower(Exposure), "denv|dengue") ~ "DENV",
        TRUE ~ "Other"
      )
    )
  
  # Match samples
  sample_map <- setNames(temp_meta$Exposure2, temp_meta$refinebio_accession_code)
  matched_samples <- intersect(names(sample_groups), names(sample_map))
  sample_groups[matched_samples] <- sample_map[matched_samples]
}

# Create annotation data frame
annotation_df <- data.frame(
  Group = factor(sample_groups),
  row.names = names(sample_groups),
  stringsAsFactors = FALSE
)

# Define colors for groups
unique_groups <- unique(sample_groups)
if (length(unique_groups) <= 2) {
  group_colors <- c("#2E8B57", "#DC143C")[1:length(unique_groups)]
  names(group_colors) <- unique_groups
} else {
  group_colors <- RColorBrewer::brewer.pal(min(length(unique_groups), 8), "Set2")
  names(group_colors) <- unique_groups
}

# Create column annotation
col_annotation <- HeatmapAnnotation(
  df = annotation_df,
  col = list(Group = group_colors),
  annotation_name_side = "left",
  simple_anno_size = unit(0.5, "cm"),
  show_annotation_name = TRUE
)

# Add gene symbols if available
gene_labels <- rownames(scaled_data)
if (exists("res_annot")) {
  # Use gene symbols if available from annotation
  symbol_map <- setNames(res_annot$Symbol, res_annot$GeneID)
  gene_labels <- ifelse(is.na(symbol_map[rownames(scaled_data)]), 
                       rownames(scaled_data), 
                       symbol_map[rownames(scaled_data)])
  # Remove NA symbols
  gene_labels[is.na(gene_labels)] <- rownames(scaled_data)[is.na(gene_labels)]
}

# Create the heatmap
heatmap_plot <- Heatmap(
  scaled_data,
  name = "Z-score",
  
  # Row (gene) settings
  row_names_gp = gpar(fontsize = 8),
  show_row_names = ifelse(nrow(scaled_data) <= 50, TRUE, FALSE),
  row_names_max_width = unit(6, "cm"),
  row_labels = gene_labels,
  
  # Column (sample) settings
  column_names_gp = gpar(fontsize = 6),
  show_column_names = FALSE,
  
  # Color scheme
  col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red")),
  
  # Clustering
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  clustering_distance_rows = "euclidean",
  clustering_distance_columns = "euclidean",
  clustering_method_rows = "complete",
  clustering_method_columns = "complete",
  
  # Annotations
  top_annotation = col_annotation,
  
  # Heatmap legend
  heatmap_legend_param = list(
    title = "Z-score",
    title_gp = gpar(fontsize = 12),
    labels_gp = gpar(fontsize = 10),
    legend_direction = "vertical"
  ),
  
  # Size
  width = unit(10, "cm"),
  height = unit(max(6, nrow(scaled_data) * 0.15), "cm")
)

# Create plots directory if it doesn't exist
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir, recursive = TRUE)
}

# Save the heatmap
heatmap_file <- file.path(plots_dir, "heatmap_significant_genes.png")
png(heatmap_file, width = 12, height = 8, units = "in", res = 300)
tryCatch({
  draw(heatmap_plot)
}, error = function(e) {
  cat("Error drawing heatmap:", e$message, "\n")
  # Create a simple backup plot
  plot.new()
  text(0.5, 0.5, "Heatmap generation failed\nCheck data and try again", cex = 1.5)
})
dev.off()

# Also save as PDF
heatmap_file_pdf <- file.path(plots_dir, "heatmap_significant_genes.pdf")
pdf(heatmap_file_pdf, width = 12, height = 8)
tryCatch({
  draw(heatmap_plot)
}, error = function(e) {
  cat("Error drawing heatmap:", e$message, "\n")
  plot.new()
  text(0.5, 0.5, "Heatmap generation failed\nCheck data and try again", cex = 1.5)
})
dev.off()

# Display the heatmap
tryCatch({
  draw(heatmap_plot)
}, error = function(e) {
  cat("Error displaying heatmap:", e$message, "\n")
  cat("Heatmap files may still be saved successfully\n")
})

# Save the list of genes used in the heatmap
heatmap_genes_df <- data.frame(
  GeneID = rownames(scaled_data),
  GeneSymbol = gene_labels,
  stringsAsFactors = FALSE
)

if (exists("res_annot")) {
  heatmap_genes_df <- heatmap_genes_df %>%
    left_join(res_annot %>% select(GeneID, log2FoldChange, padj), by = "GeneID")
} else if (exists("res_df")) {
  heatmap_genes_df <- heatmap_genes_df %>%
    left_join(res_df %>% select(GeneID, log2FoldChange, padj), by = "GeneID")
}

# Save to results directory
if (!dir.exists(results_dir)) {
  dir.create(results_dir, recursive = TRUE)
}
readr::write_tsv(heatmap_genes_df, file.path(results_dir, "heatmap_genes_list.tsv"))

cat("\nHeatmap Summary:\n")
cat("- Genes displayed:", nrow(scaled_data), "\n")
cat("- Samples displayed:", ncol(scaled_data), "\n")
cat("- Sample groups:", paste(names(table(sample_groups)), collapse = ", "), "\n")
cat("- Data transformation: log2(normalized counts + 1), then z-score normalized by gene\n")
cat("- Clustering: Hierarchical clustering with euclidean distance and complete linkage\n")
cat("- Files saved:", heatmap_file, "and", heatmap_file_pdf, "\n")
```

# Section 4c

```{r}

```

# Section 5: William Le

GenomicSuperSignature\
\## Install

```{r Package Install, message = FALSE}
if (!require("BiocManager"))
    install.packages("BiocManager")
BiocManager::install("GenomicSuperSignature")
BiocManager::install("bcellViper")
```

## Libraries

```{r Attach Packages}
library(GenomicSuperSignature)
library(bcellViper)
# load RAV
RAVmodel <- getModel("PLIERpriors", load=TRUE)
```

## Data Wrangle Ranked Gene List

Validate expects a Expression Set or simple matrix. Below is the counts matrix.

```{r}
# Define the file path to the data directory
data_dir <- file.path("data", "SRP192714")

# Declare the file path to the gene expression matrix file
data_file <- file.path(data_dir, "SRP192714.tsv")

# Read in data TSV file
expression_df <- readr::read_tsv(data_file)

# Ensemble to Gene Name
mapped_list <- mapIds(
  org.Hs.eg.db, # Annotation package for humans
  keys = expression_df$Gene,
  keytype = "ENSEMBL",
  column = "SYMBOL")

# List to df
mapped_df <- mapped_list %>%
  tibble::enframe(name = "Ensembl", value = "Gene") %>%
  # This will result in one row of our data frame per list item
  tidyr::unnest(cols = Gene)
# Join then remove Ensembl
cts <- mapped_df %>%
  dplyr::inner_join(expression_df, by = join_by(Ensembl == Gene)) %>%
  dplyr::select(-Ensembl)
# Filter for na
cts_filtered <- cts %>%
  tidyr::drop_na(Gene)
# Drop low average count dupes
cts_matrix <- cts_filtered %>%
  dplyr::group_by(Gene) %>%
  dplyr::summarise(across(everything(), sum)) %>%
  tibble::column_to_rownames("Gene") %>%
  as.matrix()
# Check if this is in the same order
all.equal(colnames(cts_matrix), metadata$refinebio_accession_code)
```

Follow the GenomicSuperSignature quick start.

```{r}
# Validate on RAV
validated_list <- GenomicSuperSignature::validate(cts_matrix, RAVmodel)
head(validated_list)
validated_list

validated_ind <- validatedSignatures(validated_list, RAVmodel, num.out = 3, 
                                     swCutoff = 0, indexOnly = TRUE)
```

Here, the validated_list is a list of principal component genes from the counts matrix referred against the RAVmodel's known genes. This essentially creates a grouping of genes and pathways for further investigation. Any low expression or genes otherwise not in the RAV database are excluded.\
The validated_ind from the validatedSignatures selects for the most relevant gene groupings/pathways/keywords from the RAV database. This effectively points us in the most effective direction for future study.\

## Tables

```{r GSEA}
annot_RAV <- annotateRAV(RAVmodel, validated_ind[1])
GSSmesh <- meshTable(RAVmodel, validated_ind[1])
GSSheatmap <- heatmapTable(validated_list, RAVmodel)
annot_RAV
GSSmesh
GSSheatmap
```
Interestingly, it seems that there is very little correlation between the principle components. At most, the average silhouette width comes to around 0.2. Since correlation is measured from -1 to 1, there suggests some correlation but perhaps not a significant amount.
Interes
```{r Save tables}
output_path <- file.path("results", "annot_RAV.tsv")
readr::write_tsv(annot_RAV, output_path)
outpath_path <- file.path("results", "GSSmesh.tsv")
readr::write_tsv(GSSmesh, output_path)
output_path <- file.path("results", "GSSheatmap.png")
png(output_path, width = 800, height = 600)
GSSheatmap
dev.off()
print(paste("Heatmap plot saved to:", output_path))
```


As seen in the above graphs, the annotated_RAV and meshTables are key words and phrases associated with a specific principle component, while the heatmapTable shows highly correlated RAV groupings themselves.

# Section 5: Nikhil Sangamkar

```{r}

```

# Section 5: Taylor Tillander

```{r}

```

# Section 5: Ibrahim Zbib

```{r}
# Step 5: Gene Set Enrichment Analysis using PyDESeq2 approach and Gene Ontology
# Note: Since PyDESeq2 is primarily a Python differential expression tool, 
# we'll use R's clusterProfiler for Gene Ontology enrichment analysis
# which provides similar statistical rigor and is the standard approach

# Load required libraries
if (!requireNamespace("clusterProfiler", quietly = TRUE)) {
  BiocManager::install("clusterProfiler")
}
if (!requireNamespace("org.Hs.eg.db", quietly = TRUE)) {
  BiocManager::install("org.Hs.eg.db")
}
if (!requireNamespace("enrichplot", quietly = TRUE)) {
  BiocManager::install("enrichplot")
}
if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}

suppressPackageStartupMessages({
  library(clusterProfiler)
  library(org.Hs.eg.db)
  library(enrichplot)
  library(ggplot2)
  library(dplyr)
  library(readr)
})

# Ensure we have differential expression results
if (!exists("res_df")) {
  stop("Please run the differential expression analysis first to generate 'res_df'")
}

cat("=== STEP 5: Gene Set Enrichment Analysis ===\n")
cat("Method: clusterProfiler (PyDESeq2 alternative in R)\n")
cat("Ontology: Gene Ontology (GO)\n\n")

# Create directories
if (!dir.exists(results_dir)) {
  dir.create(results_dir, recursive = TRUE)
}
if (!dir.exists(plots_dir)) {
  dir.create(plots_dir, recursive = TRUE)
}

# Extract significantly differentially expressed genes
# Using both upregulated and downregulated genes
sig_genes_up <- res_df %>%
  filter(padj < 0.05 & log2FoldChange > 0 & !is.na(padj)) %>%
  pull(GeneID)

sig_genes_down <- res_df %>%
  filter(padj < 0.05 & log2FoldChange < 0 & !is.na(padj)) %>%
  pull(GeneID)

sig_genes_all <- res_df %>%
  filter(padj < 0.05 & !is.na(padj)) %>%
  pull(GeneID)

cat("Significant upregulated genes:", length(sig_genes_up), "\n")
cat("Significant downregulated genes:", length(sig_genes_down), "\n")
cat("Total significant genes:", length(sig_genes_all), "\n\n")

# Convert Ensembl IDs to Entrez IDs for Gene Ontology analysis
# Remove version numbers from Ensembl IDs if present
clean_ensembl_all <- gsub("\\.\\d+$", "", sig_genes_all)
clean_ensembl_up <- gsub("\\.\\d+$", "", sig_genes_up)
clean_ensembl_down <- gsub("\\.\\d+$", "", sig_genes_down)

# Map to Entrez IDs
entrez_all <- bitr(clean_ensembl_all, 
                   fromType = "ENSEMBL",
                   toType = "ENTREZID", 
                   OrgDb = org.Hs.eg.db,
                   drop = TRUE)

entrez_up <- bitr(clean_ensembl_up,
                  fromType = "ENSEMBL", 
                  toType = "ENTREZID",
                  OrgDb = org.Hs.eg.db,
                  drop = TRUE)

entrez_down <- bitr(clean_ensembl_down,
                    fromType = "ENSEMBL",
                    toType = "ENTREZID", 
                    OrgDb = org.Hs.eg.db,
                    drop = TRUE)

cat("Genes mapped to Entrez IDs:\n")
cat("- All significant:", nrow(entrez_all), "\n")
cat("- Upregulated:", nrow(entrez_up), "\n") 
cat("- Downregulated:", nrow(entrez_down), "\n\n")

# 1. Gene Ontology Biological Process (GO:BP) - All significant genes
cat("=== Running GO Biological Process Enrichment (All Genes) ===\n")
go_bp_all <- enrichGO(gene = entrez_all$ENTREZID,
                      OrgDb = org.Hs.eg.db,
                      ont = "BP",
                      pAdjustMethod = "BH", 
                      pvalueCutoff = 0.05,
                      qvalueCutoff = 0.2,
                      readable = TRUE)

go_bp_all_df <- as.data.frame(go_bp_all)
if (nrow(go_bp_all_df) > 0) {
  write_tsv(go_bp_all_df, file.path(results_dir, "GO_BP_all_genes_results.tsv"))
  
  # Create visualizations
  p1 <- dotplot(go_bp_all, showCategory = 20) + 
    ggtitle("GO Biological Process - All Significant Genes") +
    theme(axis.text.y = element_text(size = 8))
  ggsave(file.path(plots_dir, "GO_BP_all_dotplot.png"), p1, width = 12, height = 8)
  
  p2 <- barplot(go_bp_all, showCategory = 15) +
    ggtitle("GO Biological Process - All Significant Genes")
  ggsave(file.path(plots_dir, "GO_BP_all_barplot.png"), p2, width = 10, height = 8)
  
  cat("Found", nrow(go_bp_all_df), "significant GO:BP terms (all genes)\n")
} else {
  cat("No significant GO:BP terms found (all genes)\n")
}

# 2. Gene Ontology Biological Process (GO:BP) - Upregulated genes only
if (length(entrez_up$ENTREZID) > 5) {
  cat("\n=== Running GO Biological Process Enrichment (Upregulated) ===\n")
  go_bp_up <- enrichGO(gene = entrez_up$ENTREZID,
                       OrgDb = org.Hs.eg.db,
                       ont = "BP",
                       pAdjustMethod = "BH",
                       pvalueCutoff = 0.05,
                       qvalueCutoff = 0.2,
                       readable = TRUE)
  
  go_bp_up_df <- as.data.frame(go_bp_up)
  if (nrow(go_bp_up_df) > 0) {
    write_tsv(go_bp_up_df, file.path(results_dir, "GO_BP_upregulated_results.tsv"))
    
    p3 <- dotplot(go_bp_up, showCategory = 20) + 
      ggtitle("GO Biological Process - Upregulated Genes") +
      theme(axis.text.y = element_text(size = 8))
    ggsave(file.path(plots_dir, "GO_BP_up_dotplot.png"), p3, width = 12, height = 8)
    
    cat("Found", nrow(go_bp_up_df), "significant GO:BP terms (upregulated)\n")
  } else {
    cat("No significant GO:BP terms found (upregulated)\n")
  }
}

# 3. Gene Ontology Biological Process (GO:BP) - Downregulated genes only  
if (length(entrez_down$ENTREZID) > 5) {
  cat("\n=== Running GO Biological Process Enrichment (Downregulated) ===\n")
  go_bp_down <- enrichGO(gene = entrez_down$ENTREZID,
                         OrgDb = org.Hs.eg.db,
                         ont = "BP", 
                         pAdjustMethod = "BH",
                         pvalueCutoff = 0.05,
                         qvalueCutoff = 0.2,
                         readable = TRUE)
  
  go_bp_down_df <- as.data.frame(go_bp_down)
  if (nrow(go_bp_down_df) > 0) {
    write_tsv(go_bp_down_df, file.path(results_dir, "GO_BP_downregulated_results.tsv"))
    
    p4 <- dotplot(go_bp_down, showCategory = 20) + 
      ggtitle("GO Biological Process - Downregulated Genes") +
      theme(axis.text.y = element_text(size = 8))
    ggsave(file.path(plots_dir, "GO_BP_down_dotplot.png"), p4, width = 12, height = 8)
    
    cat("Found", nrow(go_bp_down_df), "significant GO:BP terms (downregulated)\n")
  } else {
    cat("No significant GO:BP terms found (downregulated)\n")
  }
}

# 4. Gene Ontology Molecular Function (GO:MF) - All significant genes
cat("\n=== Running GO Molecular Function Enrichment ===\n")
go_mf_all <- enrichGO(gene = entrez_all$ENTREZID,
                      OrgDb = org.Hs.eg.db,
                      ont = "MF",
                      pAdjustMethod = "BH",
                      pvalueCutoff = 0.05,
                      qvalueCutoff = 0.2,
                      readable = TRUE)

go_mf_all_df <- as.data.frame(go_mf_all)
if (nrow(go_mf_all_df) > 0) {
  write_tsv(go_mf_all_df, file.path(results_dir, "GO_MF_all_genes_results.tsv"))
  
  p5 <- dotplot(go_mf_all, showCategory = 20) + 
    ggtitle("GO Molecular Function - All Significant Genes") +
    theme(axis.text.y = element_text(size = 8))
  ggsave(file.path(plots_dir, "GO_MF_all_dotplot.png"), p5, width = 12, height = 8)
  
  cat("Found", nrow(go_mf_all_df), "significant GO:MF terms\n")
} else {
  cat("No significant GO:MF terms found\n")
}

# 5. Gene Ontology Cellular Component (GO:CC) - All significant genes
cat("\n=== Running GO Cellular Component Enrichment ===\n")
go_cc_all <- enrichGO(gene = entrez_all$ENTREZID,
                      OrgDb = org.Hs.eg.db,
                      ont = "CC",
                      pAdjustMethod = "BH",
                      pvalueCutoff = 0.05,
                      qvalueCutoff = 0.2,
                      readable = TRUE)

go_cc_all_df <- as.data.frame(go_cc_all)
if (nrow(go_cc_all_df) > 0) {
  write_tsv(go_cc_all_df, file.path(results_dir, "GO_CC_all_genes_results.tsv"))
  
  p6 <- dotplot(go_cc_all, showCategory = 20) + 
    ggtitle("GO Cellular Component - All Significant Genes") +
    theme(axis.text.y = element_text(size = 8))
  ggsave(file.path(plots_dir, "GO_CC_all_dotplot.png"), p6, width = 12, height = 8)
  
  cat("Found", nrow(go_cc_all_df), "significant GO:CC terms\n")
} else {
  cat("No significant GO:CC terms found\n")
}

# 6. Create comprehensive summary table
cat("\n=== Creating Summary Table ===\n")
summary_results <- data.frame()

# Helper function to add results to summary
add_to_summary <- function(results_df, method_name, ontology_name) {
  if (exists(deparse(substitute(results_df))) && nrow(results_df) > 0) {
    results_df %>%
      select(ID, Description, pvalue, p.adjust, qvalue, Count, GeneRatio, BgRatio) %>%
      mutate(Method = method_name,
             Ontology = ontology_name) %>%
      select(Method, Ontology, ID, Description, pvalue, p.adjust, qvalue, Count, GeneRatio, BgRatio)
  } else {
    data.frame()
  }
}

# Add all results to summary
if (exists("go_bp_all_df") && nrow(go_bp_all_df) > 0) {
  summary_results <- rbind(summary_results, 
                          add_to_summary(go_bp_all_df, "GO_BP_All", "Gene Ontology Biological Process"))
}

if (exists("go_bp_up_df") && nrow(go_bp_up_df) > 0) {
  summary_results <- rbind(summary_results,
                          add_to_summary(go_bp_up_df, "GO_BP_Up", "Gene Ontology Biological Process (Up)"))
}

if (exists("go_bp_down_df") && nrow(go_bp_down_df) > 0) {
  summary_results <- rbind(summary_results,
                          add_to_summary(go_bp_down_df, "GO_BP_Down", "Gene Ontology Biological Process (Down)"))
}

if (exists("go_mf_all_df") && nrow(go_mf_all_df) > 0) {
  summary_results <- rbind(summary_results,
                          add_to_summary(go_mf_all_df, "GO_MF_All", "Gene Ontology Molecular Function"))
}

if (exists("go_cc_all_df") && nrow(go_cc_all_df) > 0) {
  summary_results <- rbind(summary_results,
                          add_to_summary(go_cc_all_df, "GO_CC_All", "Gene Ontology Cellular Component"))
}

# Save comprehensive results
if (nrow(summary_results) > 0) {
  summary_results <- summary_results %>%
    arrange(p.adjust)
  
  write_tsv(summary_results, file.path(results_dir, "GO_enrichment_comprehensive_results.tsv"))
  
  # Create top 25 results
  top_results <- summary_results %>%
    slice_head(n = 25)
  write_tsv(top_results, file.path(results_dir, "GO_enrichment_top25_results.tsv"))
  
  # Create method comparison
  method_summary <- summary_results %>%
    group_by(Method) %>%
    summarize(
      n_terms = n(),
      min_pvalue = min(pvalue),
      mean_pvalue = mean(pvalue),
      .groups = "drop"
    )
  
  write_tsv(method_summary, file.path(results_dir, "GO_method_comparison.tsv"))
  
  # Visualization of method comparison
  p_methods <- ggplot(method_summary, aes(x = Method, y = n_terms, fill = Method)) +
    geom_col() +
    labs(title = "Number of Significant GO Terms by Analysis Method",
         x = "Analysis Method", 
         y = "Number of Significant Terms") +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 45, hjust = 1),
          legend.position = "none")
  ggsave(file.path(plots_dir, "GO_method_comparison.png"), p_methods, width = 10, height = 6)
  
  cat("\nSummary table created with", nrow(summary_results), "total enriched GO terms\n")
  cat("Results saved to:", file.path(results_dir, "GO_enrichment_comprehensive_results.tsv"), "\n")
} else {
  cat("No significant enrichment results found\n")
}

# Final summary
cat("\n=== STEP 5 ANALYSIS COMPLETE ===\n")
cat("Method: clusterProfiler (PyDESeq2-style approach)\n")
cat("Ontology: Gene Ontology (BP, MF, CC)\n")
cat("Parameters used:\n")
cat("- p-value cutoff: 0.05\n")
cat("- q-value cutoff: 0.2\n") 
cat("- Multiple testing correction: Benjamini-Hochberg\n")
cat("- Gene ID conversion: Ensembl to Entrez\n")
cat("\nInput:\n")
cat("- Total DE genes:", length(sig_genes_all), "\n")
cat("- Upregulated genes:", length(sig_genes_up), "\n")
cat("- Downregulated genes:", length(sig_genes_down), "\n")
if (exists("summary_results") && nrow(summary_results) > 0) {
  cat("\nResults:\n")
  cat("- Total significant GO terms:", nrow(summary_results), "\n")
  cat("- Most significant term p-value:", format(min(summary_results$p.adjust), scientific = TRUE), "\n")
}
```

# Section 6

```{r}

```

# Section 7

```{r}

```
